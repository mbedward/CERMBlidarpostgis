% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/db_functions.R
\name{db_import_las}
\alias{db_import_las}
\title{Import data from one or more LAS files.}
\usage{
db_import_las(
  dbsettings,
  las.paths,
  dem.paths = NULL,
  mapnames = NULL,
  default.epsgs = NULL,
  purpose = c("general", "postfire"),
  check.overlap = TRUE,
  buildings = FALSE,
  union.rasters = FALSE,
  union.batch = 1
)
}
\arguments{
\item{dbsettings}{A named list of database connection settings as returned
by \code{\link{db_connect_postgis}}.}

\item{las.paths}{The paths and filenames of the LAS source files. This can
be an uncompressed (\code{.las}) or compressed \code{.laz} or \code{.zip}
file.}

\item{dem.paths}{The paths and file names of DEM (digital elevation model)
rasters corresponding to the LAS source files. If a vector of paths is
provided it must be the same length as \code{las.paths}. For each element
that specifies the path to a raster file (e.g. GeoTIFF) or zipped raster
file, the DEM data will read and used to normalize the point heights for
the corresponding LAS file. Where an element is \code{NA} or
an empty string, point heights for the corresponding LAS file will be
normalized using Delaunay triangulation. If this argument is set to
\code{NULL} (default), triangulation will be used for all LAS files.}

\item{mapnames}{Specifies the mapsheet names to store for the imported
LAS tiles. If \code{NULL} (default), mapsheet names are extracted from the
leading alphabetic portion of the LAS file names. Alternatively it can be
a character vector of either length 1 (same name for all LAS tiles) or
length equal to that of \code{las.paths}.}

\item{default.epsgs}{Integer EPSG codes for each of the imported LAS tiles.
If \code{NULL} (default), EPSG codes will be read from the LAS headers.
Sometimes (e.g. class C1 LAS files) no coordinate reference sytem is
defined in the LAS header, so it is necessary to set the code manually.}

\item{purpose}{Either \code{'general'} (default) for general purpose imagery
or \code{'postfire'} for specially flown, post-fire imagery. May be
abbreviated.}

\item{check.overlap}{If \code{TRUE} (default), images will be checked for
overlap between flight lines using the function
\code{remove_flightline_overlap} in the \code{CERMBlidar} package. If an
image fails the overlap check (i.e. it appears to have overlap and this
cannot be removed) it will be skipped. Setting this argument to
\code{FALSE} disables overlap checking. This is useful for images with
unusual configurations of flight lines that cause a false positive overlap
check.}

\item{buildings}{If \code{TRUE}, points classified as buildings (class 6)
will be imported into the \code{building_points} database table. The
default (\code{FALSE}) is to not import building points.}

\item{union.rasters}{\strong{See Details for why you probably do not want to
use this argument.} If \code{TRUE}, raster point counts derived from the
LAS images will be loaded into both the \code{point_counts} table as a
single record and the \code{point_counts_union} table where data for
spatially adjacent, overlapping rasters are merged. If \code{FALSE}
(default), raster point counts are only loaded into the \code{point_counts}
table.}

\item{union.batch}{If \code{union.rasters = TRUE}, this defines how many
rasters to load before merging data into the \code{point_counts_union}
table. The default, and minimum allowable, value is 1.}
}
\value{
A vector of integer values giving the result for each input LAS file,
  where 1 means successfully imported; 0 means skipped because previously
  imported; -1 means not imported due to error (usually a problem with
  resolving flight line overlap).
}
\description{
First, each LAS tile is read from disk and the function checks that it is
located in one of the map zones supported by the database (each zone's data
is stored in a separate schema). Next, point heights are normalized, any
overlap between flight lines is removed, and the counts of vegetation, ground
and water points are rasterized as vertical layers defined in
\code{CERMBlidar::CERMBstrata}. The point count raster layers are then
imported into the database along with meta-data for tile extent, point
density, etc. Optionally, building points can also be extracted from the LAS
tile and imported.
}
\details{
Point counts for vertical layers of vegetation are stored in the database
raster table \code{point_counts}, with a raster record for each imported LAS
tile. Typically there will be a lower density of points in edge cells of a
raster than in interior cells due to the relative position of LAS tile
boundaries and raster boundaries. This can be resolved by edge-merging
adjacent rasters, summing overlapping cells (e.g. using the PostGIS ST_UNION
operation with the 'SUM' option). The original intention was to do this by
default as part of the import process, and store an edge-merged copy of the
raster point counts data in a second database table
\code{point_counts_union}. However, we found that the time taken by the
merging operation became excessive as the number of rasters in the database
grew, although we are yet to understand exactly why this is the case. Merging
can be enabled by setting the \code{union.rasters} argument to \code{TRUE}
(default is \code{FALSE}) \strong{but this is not recommended.} Note that when
exporting point count data with function \code{db_export_stratum_counts}, the
rasters for adjacent LAS tiles will be edge-merged.
}
\examples{
\dontrun{
# Establish connection
Sys.setenv(PGPASSWORD = "mypassword")
DB <- db_connect_postgis("cermb_lidar")

# Import a set of LAS files. Point heights will be set relative
# to ground level via Delaunay triangulation.
LAS.FILES <- dir("c:/somewhere/LAS", pattern = "zip$", full.names = TRUE)
imported <- db_import_las(DB, LAS.FILES)
cat(sum(imported == 1), "files were imported\n",
    sum(imported == 0), "files already present were skipped\n",
    sum(imported == -1), "files failed to be imported\n")

# Import a set of LAS files with corresponding DEM (raster elevation)
# files to be used to normalize point heights.
LAS.FILES <- dir("c:/somewhere/LAS", pattern = "zip$", full.names = TRUE)
DEM.FILES <- dir("c:/somewhere/DEM", pattern = "zip$", full.names = TRUE)
imported <- db_import_las(DB, LAS.FILES, DEM.FILES)

}

}
